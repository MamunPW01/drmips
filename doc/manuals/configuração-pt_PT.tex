% Manual that describes how to create/edit/configure the .cpu and .set files 
% used by the simulator (en).

\documentclass[11pt,a4paper,twoside,titlepage]{report}

\usepackage[utf8x]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{color}
\usepackage{siunitx}

\newcommand{\Author}{Bruno Nova}
\newcommand{\Title}{DrMIPS -- Manual de Configuração}

\author{Bruno Nova}
\title{\Title}
\hypersetup{pdfauthor={Bruno Nova},pdftitle={\Title}}
\definecolor{cloudwhite}{cmyk}{0,0,0,0.025}
\graphicspath{{figures/}}

\lstset{
	extendedchars=\true,
	inputencoding=utf8x,
	literate={ç}{{\c{c}}}1,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\bfseries,
	numbers=left,
	numberstyle=\scriptsize\texttt,
	stepnumber=1,
	numbersep=8pt,
	frame=tblr,
	float=htb,
	aboveskip=8mm,
	belowskip=4mm,
	backgroundcolor=\color{cloudwhite},
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,	
	captionpos=b,
	breaklines=true,
	breakatwhitespace=false,
	escapeinside={\%*}{*)},
	morekeywords={*,var,template,new}
}



\begin{document}

\maketitle
\tableofcontents

\chapter{Ficheiro de CPU}

\section*{}

As diferentes versões do processador MIPS são definidas em ficheiros de CPU.
Estes podem ser editados/configurados e novos podem ser criados.
Este capítulo explica a sintaxe destes ficheiros.

Os ficheiros de CPU são formatados em JSON (\url{http://json.org/}).
Um exemplo parcial de um ficheiros de CPU é mostrado abaixo:

\lstinputlisting{listings/cpu.cpu}

As várias secções que compõe os ficheiros de CPU são detalhadas nas seguintes
secções deste capítulo.


\section{components}

Esta secção define todos os componentes do processador e suas propriedades.
Um exemplo da definição de um componente é mostrado abaixo:

\lstinputlisting{listings/component.txt}

Cada componente é identificado por um ID único (\verb+MUX_DST+ neste exemplo).
As propriedades do componente são definidas entre chavetas como um objecto
JSON. Muitas propriedades são específicas a cada tipo de componente, mas
algumas existem para todos os componentes. Estas são:

\begin{itemize}
	\item \textbf{type}: O tipo de componente. O componente no exemplo é um
		multiplexador. Os diferentes tipos de componentes são explicados a seguir.
	\item \textbf{latency}: Opcional. Um inteiro com a latência do componente em
		\SI{}{\pico\second}. A latência por omissão é \SI{0}{\pico\second}.
	\item \textbf{x}: A coordenada x do canto superior esquerdo do componente no
		caminho de dados gráfico. O valor mínimo é 0 e corresponde à borda da
		esquerda do caminho de dados. Não há valor máximo.
	\item \textbf{y}: A coordenada y do canto superior esquerdo do componente no
		caminho de dados gráfico. O valor mínimo é 0 e corresponde à borda de
		cima do caminho de dados. Não há valor máximo.
	\item \textbf{desc}: Opcional. Descrição específica do componente, em cada
		idioma, mostrada na dica do componente.
		O valor é um objecto JSON onde a descrição para cada idioma é definida na
		forma \verb+"código_idioma": "Descrição."+. O identificador
		\verb+language_code+ é o código do idioma, como \verb+pt+ ou \verb+pt_BT+.
		O idioma especial \verb+default+ deverá definir a descrição por omissão em
		Inglês que é usada quando uma descrição específica para o idioma não está
		disponível.
\end{itemize}

As subsecções seguintes explicam os diferentes tipos de componentes disponíveis
e as suas propriedades específicas.
Os títulos das subsecções são os valores que devem ser escritos na propriedade
\verb+type+ dos componentes. Esta propriedade não é sensível à capitalização.

\subsection{Add}

Um somador que soma os valores das entradas. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{ALU}

A ALU básica. Só uma ALU ou ALU Extendida pode estar presente. As propriedades
específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{control}: Identificador da entrada de controlo (que selecciona
		a operação a realizar).
	\item \textbf{out}: Identificador da saída de resultado.
	\item \textbf{zero}: Identificador da saída de 1 bit do \emph{zero}.
\end{itemize}

\subsection{ALU\_Control}

O componente que controla a ALU. Só um pode estar presente.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{aluop}: Identificador da entrada \textit{ALUOp}.
	\item \textbf{func}: Identificador da entrada \emph{func} (do campo de função
		da instrução).
\end{itemize}

\subsection{And}

uma porta lógica \emph{E}. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{Concat}

Um ``concatenador'' que concatena os valores de duas entradas numa única saída.
O valor da saída é a concatenação do valor da primeira entrada (como bits mais
significativos) com o valor da segunda entrada (como bits menos significativos).
O tamanho da saída é igual à soma dos tamanhos das entradas.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

As propriedades de ambas as entradas são definidas como objectos JSON. As
propriedades destes objectos são:
\begin{itemize}
	\item \textbf{id}: Identificador da entrada.
	\item \textbf{size}: Tamanho da entrada (em bits).
\end{itemize}

\subsection{Const}

A component that outputs a constant value. The specific properties are:
\begin{itemize}
	\item \textbf{out}: Identifier of the output.
	\item \textbf{val}: The constant value.
	\item \textbf{size}: Size of the output (in bits).
\end{itemize}

\subsection{Control}

The control unit. The datapath must have one control unit.
This component has only one specific property: \textbf{in}, which is
the identifier of the input.

\subsection{Dist}

This component distributes the bits of the input through several outputs.
The specific properties are:
\begin{itemize}
	\item \textbf{in}: Properties of the input as a JSON object.
		The properties of the object are:
		\begin{itemize}
			\item \textbf{id}: Identifier of the input.
			\item \textbf{size}: Size of the input (in bits).
		\end{itemize}
	\item \textbf{out}: Properties of the outputs as a JSON array.
		Each element of the array defines the properties of an output as a
		JSON object. The properties of the objects of the array are:
		\begin{itemize}
			\item \textbf{msb}: The index of the most significant bit from the input.
			\item \textbf{lsb}: The index of the less significant bit from the input.
			\item \textbf{id}: Optional. Identifier of the output. If omitted,
				the identifier corresponds to ``\verb+<msb>-<lsb>+''.
		\end{itemize}
\end{itemize}

\subsection{DMem}

The data memory. Only one can be present. The specific properties are:
\begin{itemize}
	\item \textbf{size}: Size of the memory (number of 32 bits memory positions).
	\item \textbf{address}: Identifier of the \textit{Address} input.
	\item \textbf{write\_data}: Identifier of the \textit{WriteData} input.
	\item \textbf{out}: Identifier of the output.
	\item \textbf{mem\_read}: Identifier of the \textit{MemRead} control input.
	\item \textbf{mem\_write}: Identifier of the \textit{MemWrite} control input.
\end{itemize}

\subsection{Ext\_ALU}

An extended ALU. This ALU stores the \verb+hi+ and \verb+lo+ registers and is
capable of calculating multiplications and divisions.
Only one ALU or Extended ALU can be present. The specific properties are the same
as the basic ALU:
\begin{itemize}
	\item \textbf{in1}: Identifier of the first input.
	\item \textbf{in2}: Identifier of the second input.
	\item \textbf{control}: Identifier of the control input (that selects the operation
		to perform).
	\item \textbf{out}: Identifier of the result output.
	\item \textbf{zero}: Identifier of the 1 bit \emph{zero} output.
\end{itemize}

\subsection{Fork}

This component forks a wire into several other wires with the same size.
The specific properties are:
\begin{itemize}
	\item \textbf{in}: Identifier of the input.
	\item \textbf{size}: Size of the input and outputs (in bits).
	\item \textbf{out}: Array with the identifiers of the outputs.
\end{itemize}

\subsection{Fwd\_Unit}

The pipeline forwarding unit. Only one can be present.
The specific properties are:
\begin{itemize}
	\item \textbf{ex\_mem\_reg\_write}: Identifier of the \textit{EX/MEM.RegWrite} input.
	\item \textbf{mem\_wb\_reg\_write}: Identifier of the \textit{MEM/WB.RegWrite} input.
	\item \textbf{ex\_mem\_rd}: Identifier of the \textit{EX/MEM.Rd} input.
	\item \textbf{mem\_wb\_rd}: Identifier of the \textit{MEM/WB.Rd} input.
	\item \textbf{id\_ex\_rs}: Identifier of the \textit{ID/EX.Rs} input.
	\item \textbf{id\_ex\_rt}: Identifier of the \textit{ID/EX.Rt} input.
	\item \textbf{fwd\_a}: Identifier of the \textit{ForwardA} output.
	\item \textbf{fwd\_b}: Identifier of the \textit{ForwardB} output.
\end{itemize}

\subsection{Hzd\_Unit}

The pipeline hazard detection unit. Only one can be present.
The specific properties are:
\begin{itemize}
	\item \textbf{id\_ex\_mem\_read}: Identifier of the \textit{ID/EX.MemRead} input.
	\item \textbf{id\_ex\_rt}: Identifier of the \textit{ID/EX.Rt} input.
	\item \textbf{if\_id\_rs}: Identifier of the \textit{IF/ID.Rs} input.
	\item \textbf{if\_id\_rt}: Identifier of the \textit{IF/ID.Rt} input.
	\item \textbf{stall}: Identifier of the output
\end{itemize}

\subsection{IMem}

The instruction memory. The datapath must have one instruction memory.
The specific properties are:
\begin{itemize}
	\item \textbf{in}: Identifier of the input.
	\item \textbf{out}: Identifier of the output.
\end{itemize}

\subsection{Mux}

A multiplexer. The specific properties are:
\begin{itemize}
	\item \textbf{size}: The size of the inputs and output (in bits).
	\item \textbf{sel}: Identifier of the selector input.
	\item \textbf{out}: Identifier of the output.
	\item \textbf{in}: Array with the identifiers of the inputs.
\end{itemize}

\subsection{Not}

A logical \textit{NOT} port. The specific properties are:
\begin{itemize}
	\item \textbf{in}: Identifier of the input.
	\item \textbf{out}: Identifier of the output.
\end{itemize}

\subsection{Or}

A logical \textit{OR} port. The specific properties are:
\begin{itemize}
	\item \textbf{in1}: Identifier of the first input.
	\item \textbf{in2}: Identifier of the second input.
	\item \textbf{out}: Identifier of the output.
\end{itemize}

\subsection{PipeReg}

A pipeline register that separates two stages of the pipeline.
A pipelined datapath must have exactly 4 of these registers (corresponding to a
5-stage pipeline). Additionally, the identifiers of these components must be:
\verb+IF/ID+, \verb+ID/EX+, \verb+EX/MEM+ and \verb+MEM/WB+.
The specific properties are:
\begin{itemize}
	\item \textbf{regs}: Definition of the registers recorded. The value is a
		JSON object where each property defines a register: the identifier is
		the identifier of the register and corresponding input and output, and
		the value is the size of the register (in bits).
	\item \textbf{flush}: Optional. Identifier of the \textit{Flush} control input.
	\item \textbf{write}: Optional. Identifier of the \textit{Write} control input.
\end{itemize}

\subsection{PC}

The program counter. The datapath must have one program counter.
The specific properties are:
\begin{itemize}
	\item \textbf{in}: Identifier of the input.
	\item \textbf{out}: Identifier of the output.
	\item \textbf{write}: Optional. Identifier of the \textit{Write} control input.
\end{itemize}

\subsection{RegBank}

The register bank. The datapath must have one register bank.
The specific properties are:
\begin{itemize}
	\item \textbf{num\_regs}: The number of registers. Must be greater than 1 and
		a power of 2.
	\item \textbf{read\_reg1}: Identifier of the \textit{ReadReg1} input.
	\item \textbf{read\_reg2}: Identifier of the \textit{ReadReg2} input.
	\item \textbf{read\_data1}: Identifier of the \textit{ReadData1} output.
	\item \textbf{read\_data2}: Identifier of the \textit{ReadData2} output.
	\item \textbf{write\_reg}: Identifier of the \textit{WriteReg} input.
	\item \textbf{write\_data}: Identifier of the \textit{WriteData} input.
	\item \textbf{reg\_write}: Identifier of the \textit{RegWrite} control input.
	\item \textbf{forwarding}: Optional. If \verb+true+ the register bank will use 
		internal forwarding (for pipelined datapaths).
	\item \textbf{const\_regs}: Optional. JSON array that defines the constant 
		registers. Each element can be either the index of the register or a JSON 
		object with the following properties:
		\begin{itemize}
			\item \textbf{reg}: Index of the register.
			\item \textbf{val}: The constant value of the register.
		\end{itemize}
\end{itemize}

\subsection{SExt}

A sign extender. The specific properties are:
\begin{itemize}
	\item \textbf{in}: Properties of the input.
	\item \textbf{out}: Properties of the output.
\end{itemize}

The properties of both the input and output are defined as JSON objects. 
The properties of these objects are:
\begin{itemize}
	\item \textbf{id}: Identifier of the input/output.
	\item \textbf{size}: Size of the input/output (in bits).
\end{itemize}

\subsection{SLL}

A shift-left logical. The specific properties are:
\begin{itemize}
	\item \textbf{in}: Properties of the input.
	\item \textbf{out}: Properties of the output.
	\item \textbf{amount}: Number of bits to shift left.
\end{itemize}

The properties of both the input and output are defined as JSON objects. 
The properties of these objects are:
\begin{itemize}
	\item \textbf{id}: Identifier of the input/output.
	\item \textbf{size}: Size of the input/output (in bits).
\end{itemize}

\subsection{Xor}

A logical \textit{XOR} port. The specific properties are:
\begin{itemize}
	\item \textbf{in1}: Identifier of the first input.
	\item \textbf{in2}: Identifier of the second input.
	\item \textbf{out}: Identifier of the output.
\end{itemize}

\subsection{ZExt}

A zero extender. The specific properties are:
\begin{itemize}
	\item \textbf{in}: Properties of the input.
	\item \textbf{out}: Properties of the output.
\end{itemize}

The properties of both the input and output are defined as JSON objects. 
The properties of these objects are:
\begin{itemize}
	\item \textbf{id}: Identifier of the input/output.
	\item \textbf{size}: Size of the input/output (in bits).
\end{itemize}


\section{wires}

This section defines all the wires that connect the components of the CPU.
An example of the definition of a wire is shown below:

\lstinputlisting{listings/wire.txt}

Each wire connects an output of a component to an input of another component.
A wire is defined as a JSON object with several properties.
These are:

\begin{itemize}
	\item \textbf{from}: The ID of the component that the wire connects from (origin).
	\item \textbf{out}: The ID of output of the origin component that the wire
		connects from.
	\item \textbf{to}: The ID of the component that the wire connects to (destination).
	\item \textbf{in}: The ID of input of the destination component that the wire
		connects to.
	\item \textbf{start}: Optional. A JSON object that defines the start position of
		the wire in the graphical datapath, if the default one is unsuitable.
	\item \textbf{points}: Optional. An array of JSON objects that define the
		positions of the intermediate points of the wire, if desired.
	\item \textbf{end}: Optional. A JSON object that defines the end position of
		the wire in the graphical datapath, if the default one is unsuitable.
\end{itemize}

The positions used in the \verb+start+, \verb+points+ and \verb+end+ properties
above are JSON objects with two integer properties: \verb+x+ and \verb+y+.
Each input and output of each component is, by default, ``attached'' to one of
the four sides of the component.
The positions of the inputs and outputs in the datapath and, thus, the start and
end positions of the connected wires, are calculated automatically\footnote{The
inputs and outputs on each side of a component are, by default, ordered 
alphabetically by their IDs.} but can be overwritten by the \verb+start+ and 
\verb+end+ properties.


\section{reg\_names}

This \textbf{optional} section defines the ``friendly'' names of the registers (i.e.
\verb+$zero+, \verb+$t0+, etc.).
The value is an array of strings that defines the names of the registers, from
register \verb+$0+ to the last one, \textbf{without the leading dollar sign}.
The registers can always be referred by their indexes (\verb+$0+, \verb+$1+, etc.) 
in the simulator.


\section{instructions}

This section declares the instruction set that the CPU uses.
The value is the \textbf{relative} path to the desired instruction set file.
These files are explained in the next chapter.


\chapter{Instruction set file}

\section*{}

The instruction sets used by the different versions of the MIPS CPU
are defined in instruction set files.
These can be edited/configured and additional ones can be created.
This chapter explains the syntax of these files.

Like the CPU files, the instruction set files are formatted in 
JSON (\url{http://json.org/}).
A partial example of an instruction set file is shown below:

\lstinputlisting{listings/set.set}

The various sections that compose the instruction set files are detailed in 
the following sections of this chapter.


\section{types}

This section defines the existing types of instructions and their fields.
All instruction are 32 bits in size.
An example of the definition of an instruction type is shown below:

\lstinputlisting{listings/type.txt}

Each instruction type is identified by its identifier (\verb+R+ in this example).
The fields of an instruction are defined in a JSON array. Each individual field is 
a JSON object and defines the field's identifier and size in bits. The first field
in this example is the \verb+op+ field with a size of 6 bits.
The first field of the instructions is considered the \emph{opcode} and must
have the same size in all types.


\section{instructions}

This section defines the available instructions and how they are encoded.
An example of the definition of an instruction is shown below:

\lstinputlisting{listings/instruction.txt}

Each instruction is identified by its unique mnemonic (\verb+add+ in this example).
An instruction is defined as a JSON object with several properties. These are:

\begin{itemize}
	\item \textbf{type}: The type of the instruction.
	\item \textbf{args}: An array with the types of each argument (may be omitted if
		the instruction has no arguments).
		The different types of arguments are:
		\begin{itemize}
			\item \textbf{reg}: A register.
			\item \textbf{int}: An integer value. Can also be a label (allowed because 
				of the \verb+la+ pseudo-instruction).
			\item \textbf{target}: A label in the code or direct instruction index for 
				a jump.
			\item \textbf{offset}: A label in the code or direct instruction offset 
				for a branch.
			\item \textbf{label}: A label in the code or data segment or direct 
				address/index.
			\item \textbf{data}: A label in the data segment of direct address plus
				an offset register for a load or store instruction (an argument like
				\verb+label($t0)+). The user may omit the offset register.
		\end{itemize}
	\item \textbf{fields}: A JSON object that defines the values of the fields
		(the fields defined in the instruction's type). The value of each field
		can either be a constant integer or come from an argument (specified as
		\verb+"#1"+, \verb+"#2"+, etc.).
		For values that come from a \verb+data+ argument it is necessary to
		specify if they come from the base address or from the offset register.
		This is done by appending \verb+.base+ or \verb+.offset+ to the reference
		to the argument (\verb+#1+, \verb+#2+, etc.).
		
		In this example: \verb+op+ has the constant value \verb+0+, \verb+rs+
		has the value from the 2nd argument, \verb+rt+ has the value from the 3rd
		argument, etc.
	\item \textbf{desc}: Optional. A string that should contain a short symbolic
		description of what the instruction does for the user to see.
\end{itemize}


\section{pseudo}

This section defines the available pseudo-instructions.
An example of the definition of an instruction is shown below:

\lstinputlisting{listings/pseudo.txt}

Each pseudo-instruction is identified by its unique mnemonic (\verb+subi+ 
in this example). Each mnemonic can only identify either an instruction or a
pseudo-instruction, not both.
A pseudo-instruction is defined as a JSON object with several properties. 
These are:

\begin{itemize}
	\item \textbf{args}: An array with the types of each argument (may be omitted if
		the pseudo-instruction has no arguments). These types are the same ones that are
		available for instructions, explained in the previous section.
	\item \textbf{to}: An array that lists the real instructions that the
		pseudo-instruction is converted to when assembled. The values of the arguments
		specified by the user can be referenced by using \verb+#1+ for the 1st argument,
		\verb+#2+ for the 2nd, and so on.
	\item \textbf{desc}: Optional. A string that should contain a short symbolic
		description of what the pseudo-instruction does for the user to see.
\end{itemize}


\section{control}

This section defines how the control unit works. More specifically, it
defines the values of the outputs (control signals) for each possible value at
the input (the \emph{opcode}).
An example of the definition of the values of the control signals for one
\emph{opcode} is shown below:

\lstinputlisting{listings/control.txt}

The values of the control signals for a specified \emph{opcode} are defined as
a JSON object. The values are in decimal format and the sizes (in bits) of the 
control signals are determined automatically.
Control signals that have the value \verb+0+ can be omitted.


\section{alu}

This section defines how the ALU and ALU control work.
A partial example of this section is shown below:

\lstinputlisting{listings/alu.txt}

The \verb+aluop_size+, \verb+func_size+ and \verb+control_size+ properties
define the sizes (in bits) of the \verb+ALUOp+ and \verb+func+ inputs of the
ALU control and of the control input of the ALU, respectively.

The \verb+control+ subsection defines how the ALU control works (in a JSON array).
Each element in the array defines (as a JSON array) the value(s) of the output(s)
for the specified value(s) of the input(s).
The \verb+aluop+ and \verb+func+ properties correspond to the values of the
inputs for the correspondence. If the value of the \verb+func+ is not relevant
for the correspondence (\emph{don't care}, can be any value), the property 
should be omitted.
The \verb+out+ property defines the values of the outputs for the correspondence.
The values are specified as a JSON object and the sizes (in bits) of the outputs
are determined automatically.
All values are in decimal format.

The \verb+operations+ subsection defines (as a JSON object) the correspondence 
between the values of the control input of the ALU and the arithmetic operation 
it performs.
The available operations are: \textbf{add}, \textbf{sub}, \textbf{and}, \textbf{or},
\textbf{slt}, \textbf{xor}, \textbf{sll}, \textbf{srl}, \textbf{sra}, \textbf{nor},
\textbf{mult}, \textbf{div}, \textbf{mfhi}, \textbf{mflo}.
Note that the last four operations require an ``extended'' ALU in the CPU, instead 
of a ``normal'' ALU.


\end{document}
