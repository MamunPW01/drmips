% Manual that describes how to create/edit/configure the .cpu and .set files 
% used by the simulator (en).

\documentclass[11pt,a4paper,twoside,titlepage]{report}

\usepackage[utf8x]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{color}
\usepackage{siunitx}

\newcommand{\Author}{Bruno Nova}
\newcommand{\Title}{DrMIPS -- Manual de Configuração}

\author{Bruno Nova}
\title{\Title}
\hypersetup{pdfauthor={Bruno Nova},pdftitle={\Title}}
\definecolor{cloudwhite}{cmyk}{0,0,0,0.025}
\graphicspath{{figures/}}

\lstset{
	extendedchars=\true,
	inputencoding=utf8x,
	literate={ç}{{\c{c}}}1,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\bfseries,
	numbers=left,
	numberstyle=\scriptsize\texttt,
	stepnumber=1,
	numbersep=8pt,
	frame=tblr,
	float=htb,
	aboveskip=8mm,
	belowskip=4mm,
	backgroundcolor=\color{cloudwhite},
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,	
	captionpos=b,
	breaklines=true,
	breakatwhitespace=false,
	escapeinside={\%*}{*)},
	morekeywords={*,var,template,new}
}



\begin{document}

\maketitle
\tableofcontents

\chapter{Ficheiro de CPU}

\section*{}

As diferentes versões do processador MIPS são definidas em ficheiros de CPU.
Estes podem ser editados/configurados e novos podem ser criados.
Este capítulo explica a sintaxe destes ficheiros.

Os ficheiros de CPU são formatados em JSON (\url{http://json.org/}).
Um exemplo parcial de um ficheiros de CPU é mostrado abaixo:

\lstinputlisting{listings/cpu.cpu}

As várias secções que compõe os ficheiros de CPU são detalhadas nas seguintes
secções deste capítulo.


\section{components}

Esta secção define todos os componentes do processador e suas propriedades.
Um exemplo da definição de um componente é mostrado abaixo:

\lstinputlisting{listings/component.txt}

Cada componente é identificado por um ID único (\verb+MUX_DST+ neste exemplo).
As propriedades do componente são definidas entre chavetas como um objecto
JSON. Muitas propriedades são específicas a cada tipo de componente, mas
algumas existem para todos os componentes. Estas são:

\begin{itemize}
	\item \textbf{type}: O tipo de componente. O componente no exemplo é um
		multiplexador. Os diferentes tipos de componentes são explicados a seguir.
	\item \textbf{latency}: Opcional. Um inteiro com a latência do componente em
		\SI{}{\pico\second}. A latência por omissão é \SI{0}{\pico\second}.
	\item \textbf{x}: A coordenada x do canto superior esquerdo do componente no
		caminho de dados gráfico. O valor mínimo é 0 e corresponde à borda da
		esquerda do caminho de dados. Não há valor máximo.
	\item \textbf{y}: A coordenada y do canto superior esquerdo do componente no
		caminho de dados gráfico. O valor mínimo é 0 e corresponde à borda de
		cima do caminho de dados. Não há valor máximo.
	\item \textbf{desc}: Opcional. Descrição específica do componente, em cada
		idioma, mostrada na dica do componente.
		O valor é um objecto JSON onde a descrição para cada idioma é definida na
		forma \verb+"código_idioma": "Descrição."+. O identificador
		\verb+language_code+ é o código do idioma, como \verb+pt+ ou \verb+pt_BT+.
		O idioma especial \verb+default+ deverá definir a descrição por omissão em
		Inglês que é usada quando uma descrição específica para o idioma não está
		disponível.
\end{itemize}

As subsecções seguintes explicam os diferentes tipos de componentes disponíveis
e as suas propriedades específicas.
Os títulos das subsecções são os valores que devem ser escritos na propriedade
\verb+type+ dos componentes. Esta propriedade não é sensível à capitalização.

\subsection{Add}

Um somador que soma os valores das entradas. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{ALU}

A ALU básica. Só uma ALU ou ALU Estendida pode estar presente. As propriedades
específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{control}: Identificador da entrada de controlo (que selecciona
		a operação a realizar).
	\item \textbf{out}: Identificador da saída de resultado.
	\item \textbf{zero}: Identificador da saída de 1 bit do \emph{zero}.
\end{itemize}

\subsection{ALU\_Control}

O componente que controla a ALU. Só um pode estar presente.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{aluop}: Identificador da entrada \emph{ALUOp}.
	\item \textbf{func}: Identificador da entrada \emph{func} (do campo de função
		da instrução).
\end{itemize}

\subsection{And}

uma porta lógica \emph{AND}. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{Concat}

Um ``concatenador'' que concatena os valores de duas entradas numa única saída.
O valor da saída é a concatenação do valor da primeira entrada (como bits mais
significativos) com o valor da segunda entrada (como bits menos significativos).
O tamanho da saída é igual à soma dos tamanhos das entradas.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

As propriedades de ambas as entradas são definidas como objectos JSON. As
propriedades destes objectos são:
\begin{itemize}
	\item \textbf{id}: Identificador da entrada.
	\item \textbf{size}: Tamanho da entrada (em bits).
\end{itemize}

\subsection{Const}

Um componente que produz um valor constante. As propriedades específicas são:
\begin{itemize}
	\item \textbf{out}: Identificador da saída.
	\item \textbf{val}: O valor constante.
	\item \textbf{size}: Tamanho da saída (em bits).
\end{itemize}

\subsection{Control}

A unidade de controlo. O caminho de dados tem de ter uma unidade de controlo.
Este componente tem apenas uma propriedade específica: \textbf{in}, que é o
identificador da entrada.

\subsection{Dist}

Este componente distribui os bits da entrada por várias saídas.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Propriedades da entrada como um objecto JSON.
		As propriedades do objecto são:
		\begin{itemize}
			\item \textbf{id}: Identificador da entrada.
			\item \textbf{size}: Tamanho da entrada (em bits).
		\end{itemize}
	\item \textbf{out}: Propriedades das saídas como um \emph{array} JSON.
		Cada elemento do \emph{array} define as propriedades de uma saída como um
		objecto JSON. As propriedades dos objectos do \emph{array} são:
		\begin{itemize}
			\item \textbf{msb}: Índice do bit mais significativo da entrada.
			\item \textbf{lsb}: Índice do bit menos significativo da entrada.
			\item \textbf{id}: Opcional. Identificador da saída. Se omitido, o
				identificador corresponde a ``\verb+<msb>-<lsb>+''.
		\end{itemize}
\end{itemize}

\subsection{DMem}

A memória de dados. Só uma pode estar presente. As propriedades específicas são:
\begin{itemize}
	\item \textbf{size}: Tamanho da memória (número de posições de memória de
		32 bits).
	\item \textbf{address}: Identificador da entrada \emph{Address}.
	\item \textbf{write\_data}: Identificador da entrada \emph{WriteData}.
	\item \textbf{out}: Identificador da saída.
	\item \textbf{mem\_read}: Identificador da entrada de controlo \emph{MemRead}.
	\item \textbf{mem\_write}: Identificador da entrada de controlo \emph{MemWrite}.
\end{itemize}

\subsection{Ext\_ALU}

Uma ALU estendida. Esta ALU armazena os registos \verb+hi+ e \verb+lo+ e é capaz
de realizar multiplicações e divisões.
Apenas uma ALU ou ALU Estendida pode estar presente. As propriedades específicas
são as mesmas da ALU básica:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{control}: Identificador da entrada de controlo (que selecciona
		a operação a realizar).
	\item \textbf{out}: Identificador da saída de resultado.
	\item \textbf{zero}: Identificador da saída de 1 bit do \emph{zero}.
\end{itemize}

\subsection{Fork}

Este componente divide uma ligação em várias outras ligações com o mesmo tamanho.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Identificador da entrada.
	\item \textbf{size}: Tamanho da entrada e das saídas (em bits).
	\item \textbf{out}: \emph{Array} com os identificadores das saídas.
\end{itemize}

\subsection{Fwd\_Unit}

A unidade de atalhos da \emph{pipeline}. Apenas uma pode estar presente.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{ex\_mem\_reg\_write}: Identificador da entrada \emph{EX/MEM.RegWrite}.
	\item \textbf{mem\_wb\_reg\_write}: Identificador da entrada \emph{MEM/WB.RegWrite}.
	\item \textbf{ex\_mem\_rd}: Identificador da entrada \emph{EX/MEM.Rd}.
	\item \textbf{mem\_wb\_rd}: Identificador da entrada \emph{MEM/WB.Rd}.
	\item \textbf{id\_ex\_rs}: Identificador da entrada \emph{ID/EX.Rs}.
	\item \textbf{id\_ex\_rt}: Identificador da entrada \emph{ID/EX.Rt}.
	\item \textbf{fwd\_a}: Identificador da saída \emph{ForwardA}.
	\item \textbf{fwd\_b}: Identificador da saída \emph{ForwardB}.
\end{itemize}

\subsection{Hzd\_Unit}
A unidade de detecção de conflitos da \emph{pipeline}. Apenas uma pode estar
presente.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{id\_ex\_mem\_read}: Identificador da entrada \emph{ID/EX.MemRead}.
	\item \textbf{id\_ex\_rt}: Identificador da entrada \emph{ID/EX.Rt}.
	\item \textbf{if\_id\_rs}: Identificador da entrada \emph{IF/ID.Rs}.
	\item \textbf{if\_id\_rt}: Identificador da entrada \emph{IF/ID.Rt}.
	\item \textbf{stall}: Identificador da saída.
\end{itemize}

\subsection{IMem}

A memória de instruções. O caminho de dados tem de ter uma memória de instruções.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Identificador da entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{Mux}

Um multiplexador. As propriedades específicas são:
\begin{itemize}
	\item \textbf{size}: O tamanho das entradas e saída (em bits).
	\item \textbf{sel}: Identificador da entrada de selecção.
	\item \textbf{out}: Identificador da saída.
	\item \textbf{in}: \emph{Array} com os identificadores das saídas.
\end{itemize}

\subsection{Not}

Uma porta lógica \emph{NOT}. As propriedades específicas são:
\begin{itemize}

\end{itemize}
	\item \textbf{in}: Identificador da entrada.
	\item \textbf{out}: Identificador da saída.
\subsection{Or}

Uma porta lógica \emph{OR}. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{PipeReg}

Um registo de \emph{pipeline} que separa duas etapas da \emph{pipeline}.
Um caminho de dados \emph{pipeline} tem de ter exactamente 4 destes registos
(correspondentes a um \emph{pipeline} de 5 etapas). Adicionalmente, os
identificadores destes componentes têm de ser:
\verb+IF/ID+, \verb+ID/EX+, \verb+EX/MEM+ and \verb+MEM/WB+.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{regs}: Definição dos registos guardados. O valor é um objecto
		JSON onde cada propriedade define um registo: o identificador é o
		identificador do registo e correspondente entrada e saída, e o valor é o
		tamanho do registo (em bits).
	\item \textbf{flush}: Opcional. Identificador da entrada de controlo \emph{Flush}.
	\item \textbf{write}: Opcional. Identificador da entrada de controlo \emph{Write}.
\end{itemize}

\subsection{PC}

O contador do programa. O caminho de dados tem de ter um contador do programa.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Identificador da entrada.
	\item \textbf{out}: Identificador da saída.
	\item \textbf{write}: Opcional. Identificador da saída de controlo \emph{Write}.
\end{itemize}

\subsection{RegBank}

O banco de registos. O caminho de dados tem de ter um banco de registos.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{num\_regs}: O número de registos. Tem de ser maior do que 1 e
		uma potência de 2.
	\item \textbf{read\_reg1}: Identificador da entrada \emph{ReadReg1}.
	\item \textbf{read\_reg2}: Identificador da entrada \emph{ReadReg2}.
	\item \textbf{read\_data1}: Identificador da saída \emph{ReadData1}.
	\item \textbf{read\_data2}: Identificador da saída \emph{ReadData2}.
	\item \textbf{write\_reg}: Identificador da entrada \emph{WriteReg}.
	\item \textbf{write\_data}: Identificador da entrada \emph{WriteData}.
	\item \textbf{reg\_write}: Identificador da entrada de controlo \emph{RegWrite}.
	\item \textbf{forwarding}: Opcional. Se \verb+true+, o banco de registos irá
		usar atalhos internos (para caminhos de dados \emph{pipeline}.
	\item \textbf{const\_regs}: Opcional. \emph{Array} JSON que define os registos
		constantes. Cada elemento é ou o índice do registo ou um objecto JSON com
		as seguintes propriedades:
		\begin{itemize}
			\item \textbf{reg}: Índice do registo.
			\item \textbf{val}: O valor constante do registo.
		\end{itemize}
\end{itemize}

\subsection{SExt}

Uma extensão de sinal. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Propriedades da entrada.
	\item \textbf{out}: Propriedades da saída.
\end{itemize}

As propriedades das entradas e das saídas são definidas como objectos JSON.
As propriedades destes objectos são:
\begin{itemize}
	\item \textbf{id}: Identificador da entrada/saída.
	\item \textbf{size}: Tamanho da entrada/saída (em bits).
\end{itemize}

\subsection{SLL}

Um deslocador para a esquerda. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Propriedades da entrada.
	\item \textbf{out}: Propriedades da saída.
	\item \textbf{amount}: Número de bits a deslocar
\end{itemize}

As propriedades das entradas e das saídas são definidas como objectos JSON.
As propriedades destes objectos são:
\begin{itemize}
	\item \textbf{id}: Identificador da entrada/saída.
	\item \textbf{size}: Tamanho da entrada/saída (em bits).
\end{itemize}

\subsection{Xor}

Uma porta lógica \emph{XOR}. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{ZExt}
Uma extensão de valor. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Propriedades da entrada.
	\item \textbf{out}: Propriedades da saída.
\end{itemize}

As propriedades das entradas e das saídas são definidas como objectos JSON.
As propriedades destes objectos são:
\begin{itemize}
	\item \textbf{id}: Identificador da entrada/saída.
	\item \textbf{size}: Tamanho da entrada/saída (em bits).
\end{itemize}


\section{wires}

Esta secção define todas as ligações que conectam os componentes do CPU.
Um exemplo da definição de uma ligação é mostrado abaixo:

\lstinputlisting{listings/wire.txt}

Cada ligação conecta uma saída de um componente à entrada de outro componente.
Uma ligação é definida como um objecto JSON com várias propriedades.
Estas são:

\begin{itemize}
	\item \textbf{from}: O ID do componente que de onde a conexão é feita (origem).
	\item \textbf{out}:O ID da saída do componente de origem de onde a conexão é
		feita.
	\item \textbf{to}: O ID do componente para onde a conexão é feita (destino).
	\item \textbf{in}: O ID da entrada do componente de destino para onde a conexão
		é feita.
	\item \textbf{start}: Opcional. Um objecto JSON que define a posição gráfica
		de início no caminho de dados, se a posição por omissão não é a desejável.
	\item \textbf{points}: Opcional. Um \emph{Array} de objectos JSON que definem
		as posições dos pontos intermédios da ligação, de desejado.
	\item \textbf{end}: Opcional. Um objecto JSON que define a posição gráfica
		final no caminho de dados, se a posição por omissão não é a desejável.
\end{itemize}

As posições usadas nas propriedades \verb+start+, \verb+points+ and \verb+end+
acima são objectos JSON com duas propriedades inteiras: \verb+x+ e \verb+y+.
Cada entrada e saída de cada componente é, por omissão, ``anexada'' a um dos
quatro lados do componente.
As posições das entradas e saídas no caminho de dados e, portanto, as posições
de início e fim das ligações, são calculadas automaticamente\footnote{As
entradas e saídas em cada lado do componente são, por omissão, ordenadas
alfabeticamente pelos seus identificadores.} mas podem ser sobrescritas pelas
propriedades \verb+start+ e \verb+end+.


\section{reg\_names}

Esta secção \textbf{opcional} define os nomes ``amigáveis'' dos registos (i.e.
\verb+$zero+, \verb+$t0+, etc.).
O valor é um \emph{array} de \emph{strings} que definem os nomes dos registos,
desde o registo \verb+$0+ até ao último, \textbf{sem o sinal de dólar inicial}.
Os registos podem sempre ser referenciados pelos seus índices (\verb+$0+,
\verb+$1+, etc.) no simulador.


\section{instructions}

Esta secção declara o conjunto de instruções que o processador usa.
O valor é o caminho \textbf{relativo} para ficheiro de instruções desejado.
Estes ficheiros são explicados no próximo capítulo.


\chapter{Instruction set file}

\section*{}

The instruction sets used by the different versions of the MIPS CPU
are defined in instruction set files.
These can be edited/configured and additional ones can be created.
This chapter explains the syntax of these files.

Like the CPU files, the instruction set files are formatted in 
JSON (\url{http://json.org/}).
A partial example of an instruction set file is shown below:

\lstinputlisting{listings/set.set}

The various sections that compose the instruction set files are detailed in 
the following sections of this chapter.


\section{types}

This section defines the existing types of instructions and their fields.
All instruction are 32 bits in size.
An example of the definition of an instruction type is shown below:

\lstinputlisting{listings/type.txt}

Each instruction type is identified by its identifier (\verb+R+ in this example).
The fields of an instruction are defined in a JSON array. Each individual field is 
a JSON object and defines the field's identifier and size in bits. The first field
in this example is the \verb+op+ field with a size of 6 bits.
The first field of the instructions is considered the \emph{opcode} and must
have the same size in all types.


\section{instructions}

This section defines the available instructions and how they are encoded.
An example of the definition of an instruction is shown below:

\lstinputlisting{listings/instruction.txt}

Each instruction is identified by its unique mnemonic (\verb+add+ in this example).
An instruction is defined as a JSON object with several properties. These are:

\begin{itemize}
	\item \textbf{type}: The type of the instruction.
	\item \textbf{args}: An array with the types of each argument (may be omitted if
		the instruction has no arguments).
		The different types of arguments are:
		\begin{itemize}
			\item \textbf{reg}: A register.
			\item \textbf{int}: An integer value. Can also be a label (allowed because 
				of the \verb+la+ pseudo-instruction).
			\item \textbf{target}: A label in the code or direct instruction index for 
				a jump.
			\item \textbf{offset}: A label in the code or direct instruction offset 
				for a branch.
			\item \textbf{label}: A label in the code or data segment or direct 
				address/index.
			\item \textbf{data}: A label in the data segment of direct address plus
				an offset register for a load or store instruction (an argument like
				\verb+label($t0)+). The user may omit the offset register.
		\end{itemize}
	\item \textbf{fields}: A JSON object that defines the values of the fields
		(the fields defined in the instruction's type). The value of each field
		can either be a constant integer or come from an argument (specified as
		\verb+"#1"+, \verb+"#2"+, etc.).
		For values that come from a \verb+data+ argument it is necessary to
		specify if they come from the base address or from the offset register.
		This is done by appending \verb+.base+ or \verb+.offset+ to the reference
		to the argument (\verb+#1+, \verb+#2+, etc.).
		
		In this example: \verb+op+ has the constant value \verb+0+, \verb+rs+
		has the value from the 2nd argument, \verb+rt+ has the value from the 3rd
		argument, etc.
	\item \textbf{desc}: Optional. A string that should contain a short symbolic
		description of what the instruction does for the user to see.
\end{itemize}


\section{pseudo}

This section defines the available pseudo-instructions.
An example of the definition of an instruction is shown below:

\lstinputlisting{listings/pseudo.txt}

Each pseudo-instruction is identified by its unique mnemonic (\verb+subi+ 
in this example). Each mnemonic can only identify either an instruction or a
pseudo-instruction, not both.
A pseudo-instruction is defined as a JSON object with several properties. 
These are:

\begin{itemize}
	\item \textbf{args}: An array with the types of each argument (may be omitted if
		the pseudo-instruction has no arguments). These types are the same ones that are
		available for instructions, explained in the previous section.
	\item \textbf{to}: An array that lists the real instructions that the
		pseudo-instruction is converted to when assembled. The values of the arguments
		specified by the user can be referenced by using \verb+#1+ for the 1st argument,
		\verb+#2+ for the 2nd, and so on.
	\item \textbf{desc}: Optional. A string that should contain a short symbolic
		description of what the pseudo-instruction does for the user to see.
\end{itemize}


\section{control}

This section defines how the control unit works. More specifically, it
defines the values of the outputs (control signals) for each possible value at
the input (the \emph{opcode}).
An example of the definition of the values of the control signals for one
\emph{opcode} is shown below:

\lstinputlisting{listings/control.txt}

The values of the control signals for a specified \emph{opcode} are defined as
a JSON object. The values are in decimal format and the sizes (in bits) of the 
control signals are determined automatically.
Control signals that have the value \verb+0+ can be omitted.


\section{alu}

This section defines how the ALU and ALU control work.
A partial example of this section is shown below:

\lstinputlisting{listings/alu.txt}

The \verb+aluop_size+, \verb+func_size+ and \verb+control_size+ properties
define the sizes (in bits) of the \verb+ALUOp+ and \verb+func+ inputs of the
ALU control and of the control input of the ALU, respectively.

The \verb+control+ subsection defines how the ALU control works (in a JSON array).
Each element in the array defines (as a JSON array) the value(s) of the output(s)
for the specified value(s) of the input(s).
The \verb+aluop+ and \verb+func+ properties correspond to the values of the
inputs for the correspondence. If the value of the \verb+func+ is not relevant
for the correspondence (\emph{don't care}, can be any value), the property 
should be omitted.
The \verb+out+ property defines the values of the outputs for the correspondence.
The values are specified as a JSON object and the sizes (in bits) of the outputs
are determined automatically.
All values are in decimal format.

The \verb+operations+ subsection defines (as a JSON object) the correspondence 
between the values of the control input of the ALU and the arithmetic operation 
it performs.
The available operations are: \textbf{add}, \textbf{sub}, \textbf{and}, \textbf{or},
\textbf{slt}, \textbf{xor}, \textbf{sll}, \textbf{srl}, \textbf{sra}, \textbf{nor},
\textbf{mult}, \textbf{div}, \textbf{mfhi}, \textbf{mflo}.
Note that the last four operations require an ``extended'' ALU in the CPU, instead 
of a ``normal'' ALU.


\end{document}
