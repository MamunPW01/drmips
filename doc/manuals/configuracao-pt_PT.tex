% Manual that describes how to create/edit/configure the .cpu and .set files 
% used by the simulator (pt_PT).

\documentclass[11pt,a4paper,twoside,titlepage]{report}

\usepackage[utf8x]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{color}
\usepackage{siunitx}

\newcommand{\Author}{Bruno Nova}
\newcommand{\Title}{DrMIPS -- Manual de Configuração}

\author{Bruno Nova}
\title{\Title}
\hypersetup{pdfauthor={Bruno Nova},pdftitle={\Title}}
\definecolor{cloudwhite}{cmyk}{0,0,0,0.025}
\graphicspath{{figures/}}

\lstset{
	extendedchars=\true,
	inputencoding=utf8x,
	literate={ç}{{\c{c}}}1,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\bfseries,
	numbers=left,
	numberstyle=\scriptsize\texttt,
	stepnumber=1,
	numbersep=8pt,
	frame=tblr,
	float=htb,
	aboveskip=8mm,
	belowskip=4mm,
	backgroundcolor=\color{cloudwhite},
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,	
	captionpos=b,
	breaklines=true,
	breakatwhitespace=false,
	escapeinside={\%*}{*)},
	morekeywords={*,var,template,new}
}



\begin{document}

\maketitle
\tableofcontents


\chapter{Introdução}

\section*{}

O DrMIPS fornece vários caminhos de dados uniciclo e \emph{pipeline} do MIPS.
Estes caminhos de dados são definidos em ficheiros JSON (\url{http://json.org/}),
e têm a extensão \verb+.cpu+.
Estes ficheiros de CPU podem ser modificados, e novos podem ser criados.

Os conjuntos de instruções usados pelos caminhos de dados são também definidos
em ficheiros JSON, usando a extensão \verb+.set+.
Estes podem também ser criados e modificados.

Este manual explica, com algum detalhe, a sintaxe de ambos estes ficheiros.
O Capítulo~\ref{ch:cpu} explica a sintaxe dos ficheiros de CPU enquanto que
o Capítulo~\ref{ch:set} explica a sintaxe dos ficheiros de instruções.


\chapter{Ficheiro de CPU} \label{ch:cpu}

\section*{}

As diferentes versões do processador MIPS são definidas em ficheiros de CPU.
Estes podem ser editados/configurados e novos podem ser criados.
Este capítulo explica a sintaxe destes ficheiros.

Os ficheiros de CPU são formatados em JSON.
Um exemplo parcial de um ficheiros de CPU é mostrado abaixo:

\lstinputlisting{listings/cpu.cpu}

As várias secções que compõe os ficheiros de CPU são detalhadas nas seguintes
secções deste capítulo.


\section{components}

Esta secção define todos os componentes do processador e suas propriedades.
Um exemplo da definição de um componente é mostrado abaixo:

\lstinputlisting{listings/component.txt}

Cada componente é identificado por um ID único (\verb+MUX_DST+ neste exemplo).
As propriedades do componente são definidas entre chavetas como um objecto
JSON. Muitas propriedades são específicas a cada tipo de componente, mas
algumas existem para todos os componentes. Estas são:

\begin{itemize}
	\item \textbf{type}: O tipo de componente. O componente no exemplo é um
		multiplexador. Os diferentes tipos de componentes são explicados a seguir.
	\item \textbf{latency}: Opcional. Um inteiro com a latência do componente em
		\SI{}{\pico\second}. A latência por omissão é \SI{0}{\pico\second}.
	\item \textbf{x}: A coordenada x do canto superior esquerdo do componente no
		caminho de dados gráfico. O valor mínimo é 0 e corresponde à borda da
		esquerda do caminho de dados. Não há valor máximo.
	\item \textbf{y}: A coordenada y do canto superior esquerdo do componente no
		caminho de dados gráfico. O valor mínimo é 0 e corresponde à borda de
		cima do caminho de dados. Não há valor máximo.
	\item \textbf{desc}: Opcional. Descrição específica do componente, em cada
		idioma, mostrada na dica de ajuda do componente.
		O valor é um objecto JSON onde a descrição para cada idioma é definida na
		forma \verb+"código_idioma": "Descrição."+. O identificador
		\verb+código_idioma+ é o código do idioma, como \verb+pt+ ou \verb+pt_BR+.
		O idioma especial \verb+default+ deverá definir a descrição por omissão em
		Inglês que é usada quando uma descrição específica para o idioma não está
		disponível.
\end{itemize}

As subsecções seguintes explicam os diferentes tipos de componentes disponíveis
e as suas propriedades específicas.
Os títulos das subsecções são os valores que devem ser escritos na propriedade
\verb+type+ dos componentes. Esta propriedade não é sensível à capitalização.

\subsection{Add}

Um somador que soma os valores das entradas. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{ALU}

A ALU básica. Só uma ALU ou ALU Estendida pode estar presente. As propriedades
específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{control}: Identificador da entrada de controlo (que selecciona
		a operação a realizar).
	\item \textbf{out}: Identificador da saída de resultado.
	\item \textbf{zero}: Identificador da saída de 1 bit do \emph{zero}.
\end{itemize}

\subsection{ALU\_Control}

O componente que controla a ALU. Só um pode estar presente.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{aluop}: Identificador da entrada \emph{ALUOp}.
	\item \textbf{func}: Identificador da entrada \emph{func} (do campo de função
		da instrução).
\end{itemize}

\subsection{And}

Uma porta lógica \emph{AND}. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{Concat}

Um ``concatenador'' que concatena os valores de duas entradas numa única saída.
O valor da saída é a concatenação do valor da primeira entrada (como bits mais
significativos) com o valor da segunda entrada (como bits menos significativos).
O tamanho da saída é igual à soma dos tamanhos das entradas.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

As propriedades de ambas as entradas são definidas como objectos JSON. As
propriedades destes objectos são:
\begin{itemize}
	\item \textbf{id}: Identificador da entrada.
	\item \textbf{size}: Tamanho da entrada (em bits).
\end{itemize}

\subsection{Const}

Um componente que produz um valor constante. As propriedades específicas são:
\begin{itemize}
	\item \textbf{out}: Identificador da saída.
	\item \textbf{val}: O valor constante.
	\item \textbf{size}: Tamanho da saída (em bits).
\end{itemize}

\subsection{Control}

A unidade de controlo. O caminho de dados tem de ter uma unidade de controlo.
Este componente tem apenas uma propriedade específica: \textbf{in}, que é o
identificador da entrada.

\subsection{Dist}

Este componente distribui os bits da entrada por várias saídas.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Propriedades da entrada como um objecto JSON.
		As propriedades do objecto são:
		\begin{itemize}
			\item \textbf{id}: Identificador da entrada.
			\item \textbf{size}: Tamanho da entrada (em bits).
		\end{itemize}
	\item \textbf{out}: Propriedades das saídas como um \emph{array} JSON.
		Cada elemento do \emph{array} define as propriedades de uma saída como um
		objecto JSON. As propriedades dos objectos do \emph{array} são:
		\begin{itemize}
			\item \textbf{msb}: Índice do bit mais significativo da entrada.
			\item \textbf{lsb}: Índice do bit menos significativo da entrada.
			\item \textbf{id}: Opcional. Identificador da saída. Se omitido, o
				identificador corresponde a ``\verb+<msb>-<lsb>+''.
		\end{itemize}
\end{itemize}

\subsection{DMem}

A memória de dados. Só uma pode estar presente. As propriedades específicas são:
\begin{itemize}
	\item \textbf{size}: Tamanho da memória (número de posições de memória de
		32 bits).
	\item \textbf{address}: Identificador da entrada \emph{Address}.
	\item \textbf{write\_data}: Identificador da entrada \emph{WriteData}.
	\item \textbf{out}: Identificador da saída.
	\item \textbf{mem\_read}: Identificador da entrada de controlo \emph{MemRead}.
	\item \textbf{mem\_write}: Identificador da entrada de controlo \emph{MemWrite}.
\end{itemize}

\subsection{Ext\_ALU}

Uma ALU estendida. Esta ALU armazena os registos \verb+hi+ e \verb+lo+ e é capaz
de realizar multiplicações e divisões.
Apenas uma ALU ou ALU Estendida pode estar presente. As propriedades específicas
são as mesmas da ALU básica:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{control}: Identificador da entrada de controlo (que selecciona
		a operação a realizar).
	\item \textbf{out}: Identificador da saída de resultado.
	\item \textbf{zero}: Identificador da saída de 1 bit do \emph{zero}.
\end{itemize}

\subsection{Fork}

Este componente divide uma ligação em várias outras ligações com o mesmo tamanho.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Identificador da entrada.
	\item \textbf{size}: Tamanho da entrada e das saídas (em bits).
	\item \textbf{out}: \emph{Array} com os identificadores das saídas.
\end{itemize}

\subsection{Fwd\_Unit}

A unidade de atalhos da \emph{pipeline}. Apenas uma pode estar presente.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{ex\_mem\_reg\_write}: Identificador da entrada\\ \emph{EX/MEM.RegWrite}.
	\item \textbf{mem\_wb\_reg\_write}: Identificador da entrada\\ \emph{MEM/WB.RegWrite}.
	\item \textbf{ex\_mem\_rd}: Identificador da entrada \emph{EX/MEM.Rd}.
	\item \textbf{mem\_wb\_rd}: Identificador da entrada \emph{MEM/WB.Rd}.
	\item \textbf{id\_ex\_rs}: Identificador da entrada \emph{ID/EX.Rs}.
	\item \textbf{id\_ex\_rt}: Identificador da entrada \emph{ID/EX.Rt}.
	\item \textbf{fwd\_a}: Identificador da saída \emph{ForwardA}.
	\item \textbf{fwd\_b}: Identificador da saída \emph{ForwardB}.
\end{itemize}

\subsection{Hzd\_Unit}
A unidade de detecção de conflitos da \emph{pipeline}. Apenas uma pode estar
presente.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{id\_ex\_mem\_read}: Identificador da entrada \emph{ID/EX.MemRead}.
	\item \textbf{id\_ex\_rt}: Identificador da entrada \emph{ID/EX.Rt}.
	\item \textbf{if\_id\_rs}: Identificador da entrada \emph{IF/ID.Rs}.
	\item \textbf{if\_id\_rt}: Identificador da entrada \emph{IF/ID.Rt}.
	\item \textbf{stall}: Identificador da saída.
\end{itemize}

\subsection{IMem}

A memória de instruções. O caminho de dados tem de ter uma memória de instruções.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Identificador da entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{Mux}

Um multiplexador. As propriedades específicas são:
\begin{itemize}
	\item \textbf{size}: O tamanho das entradas e saída (em bits).
	\item \textbf{sel}: Identificador da entrada de selecção.
	\item \textbf{out}: Identificador da saída.
	\item \textbf{in}: \emph{Array} com os identificadores das saídas.
\end{itemize}

\subsection{Not}

Uma porta lógica \emph{NOT}. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Identificador da entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{Or}

Uma porta lógica \emph{OR}. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{PipeReg}

Um registo de \emph{pipeline} que separa duas etapas da \emph{pipeline}.
Um caminho de dados \emph{pipeline} tem de ter exactamente 4 destes registos
(correspondentes a um \emph{pipeline} de 5 etapas). Adicionalmente, os
identificadores destes componentes têm de ser:
\verb+IF/ID+, \verb+ID/EX+, \verb+EX/MEM+ and \verb+MEM/WB+.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{regs}: Definição dos registos guardados. O valor é um objecto
		JSON onde cada propriedade define um registo: o identificador é o
		identificador do registo e correspondente entrada e saída, e o valor é o
		tamanho do registo (em bits).
	\item \textbf{flush}: Opcional. Identificador da entrada de controlo \emph{Flush}.
	\item \textbf{write}: Opcional. Identificador da entrada de controlo \emph{Write}.
\end{itemize}

\subsection{PC}

O contador do programa. O caminho de dados tem de ter um contador do programa.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Identificador da entrada.
	\item \textbf{out}: Identificador da saída.
	\item \textbf{write}: Opcional. Identificador da saída de controlo \emph{Write}.
\end{itemize}

\subsection{RegBank}

O banco de registos. O caminho de dados tem de ter um banco de registos.
As propriedades específicas são:
\begin{itemize}
	\item \textbf{num\_regs}: O número de registos. Tem de ser maior do que 1 e
		uma potência de 2.
	\item \textbf{read\_reg1}: Identificador da entrada \emph{ReadReg1}.
	\item \textbf{read\_reg2}: Identificador da entrada \emph{ReadReg2}.
	\item \textbf{read\_data1}: Identificador da saída \emph{ReadData1}.
	\item \textbf{read\_data2}: Identificador da saída \emph{ReadData2}.
	\item \textbf{write\_reg}: Identificador da entrada \emph{WriteReg}.
	\item \textbf{write\_data}: Identificador da entrada \emph{WriteData}.
	\item \textbf{reg\_write}: Identificador da entrada de controlo \emph{RegWrite}.
	\item \textbf{forwarding}: Opcional. Se \verb+true+, o banco de registos irá
		usar atalhos internos (para caminhos de dados \emph{pipeline}).
	\item \textbf{const\_regs}: Opcional. \emph{Array} JSON que define os registos
		constantes. Cada elemento é ou o índice do registo ou um objecto JSON com
		as seguintes propriedades:
		\begin{itemize}
			\item \textbf{reg}: Índice do registo.
			\item \textbf{val}: O valor constante do registo.
		\end{itemize}
\end{itemize}

\subsection{SExt}

Uma extensão de sinal. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Propriedades da entrada.
	\item \textbf{out}: Propriedades da saída.
\end{itemize}

As propriedades da entrada e da saída são definidas como objectos JSON.
As propriedades destes objectos são:
\begin{itemize}
	\item \textbf{id}: Identificador da entrada/saída.
	\item \textbf{size}: Tamanho da entrada/saída (em bits).
\end{itemize}

\subsection{SLL}

Um deslocador para a esquerda. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Propriedades da entrada.
	\item \textbf{out}: Propriedades da saída.
	\item \textbf{amount}: Número de bits a deslocar
\end{itemize}

As propriedades da entrada e da saída são definidas como objectos JSON.
As propriedades destes objectos são:
\begin{itemize}
	\item \textbf{id}: Identificador da entrada/saída.
	\item \textbf{size}: Tamanho da entrada/saída (em bits).
\end{itemize}

\subsection{Xor}

Uma porta lógica \emph{XOR}. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in1}: Identificador da primeira entrada.
	\item \textbf{in2}: Identificador da segunda entrada.
	\item \textbf{out}: Identificador da saída.
\end{itemize}

\subsection{ZExt}
Uma extensão de valor. As propriedades específicas são:
\begin{itemize}
	\item \textbf{in}: Propriedades da entrada.
	\item \textbf{out}: Propriedades da saída.
\end{itemize}

As propriedades da entrada e da saída são definidas como objectos JSON.
As propriedades destes objectos são:
\begin{itemize}
	\item \textbf{id}: Identificador da entrada/saída.
	\item \textbf{size}: Tamanho da entrada/saída (em bits).
\end{itemize}


\section{wires}

Esta secção define todas as ligações que conectam os componentes do CPU.
Um exemplo da definição de uma ligação é mostrado abaixo:

\lstinputlisting{listings/wire.txt}

Cada ligação conecta uma saída de um componente à entrada de outro componente.
Uma ligação é definida como um objecto JSON com várias propriedades.
Estas são:

\begin{itemize}
	\item \textbf{from}: O ID do componente de onde a conexão é feita (origem).
	\item \textbf{out}: O ID da saída do componente de origem de onde a conexão é
		feita.
	\item \textbf{to}: O ID do componente para onde a conexão é feita (destino).
	\item \textbf{in}: O ID da entrada do componente de destino para onde a conexão
		é feita.
	\item \textbf{start}: Opcional. Um objecto JSON que define a posição gráfica
		de início no caminho de dados, se a posição por omissão não é a desejável.
	\item \textbf{points}: Opcional. Um \emph{Array} de objectos JSON que definem
		as posições dos pontos intermédios da ligação, se desejado.
	\item \textbf{end}: Opcional. Um objecto JSON que define a posição gráfica
		final no caminho de dados, se a posição por omissão não é a desejável.
\end{itemize}

As posições usadas nas propriedades \verb+start+, \verb+points+ and \verb+end+
acima são objectos JSON com duas propriedades inteiras: \verb+x+ e \verb+y+.
Cada entrada e saída de cada componente é, por omissão, ``anexada'' a um dos
quatro lados do componente.
As posições das entradas e saídas no caminho de dados e, portanto, as posições
de início e fim das ligações, são calculadas automaticamente\footnote{As
entradas e saídas em cada lado do componente são, por omissão, ordenadas
alfabeticamente pelos seus identificadores.} mas podem ser sobrescritas pelas
propriedades \verb+start+ e \verb+end+.


\section{reg\_names}

Esta secção \textbf{opcional} define os nomes ``amigáveis'' dos registos (i.e.
\verb+$zero+, \verb+$t0+, etc.).
O valor é um \emph{array} de \emph{strings} que definem os nomes dos registos,
desde o registo \verb+$0+ até ao último, \textbf{sem o símbolo do dólar inicial}.
Os registos podem sempre ser referenciados pelos seus índices (\verb+$0+,
\verb+$1+, etc.) no simulador.


\section{instructions}

Esta secção declara o conjunto de instruções que o processador usa.
O valor é o caminho \textbf{relativo} para ficheiro de instruções desejado.
Estes ficheiros são explicados no próximo capítulo.


\chapter{Ficheiro de instruções} \label{ch:set}

\section*{}

Os conjuntos de instruções usados pelas diferentes versões do processador MIPS
são definidos em ficheiros de instruções.
Estes podem ser editados/configurados e novos podem ser criados.
Este capítulo explica a sintaxe destes ficheiros.

Tal como os ficheiros de CPU, os ficheiros de instruções são formatados em JSON.
Um exemplo parcial de um ficheiro de instruções é mostrado abaixo:

\lstinputlisting{listings/set.set}

As várias secções que compõe os ficheiros de instruções são detalhadas nas
seguintes secções deste capítulo.


\section{types}

Esta secção define os tipos de instruções existentes e os seus campos.
Todas as instruções têm um tamanho de 32 bits.
Um exemplo da definição de um tipo de instrução é mostrado abaixo:

\lstinputlisting{listings/type.txt}

Cada tipo de instrução é definido pelo seu identificador (\verb+R+ neste exemplo).
Os campos de uma instrução são definidos num \emph{array} JSON. Cada campo
individual é um objecto JSON e define o identificador do campo e seu tamanho em
bits. O primeiro campo neste exemplo é o campo \verb+op+ com um tamanho de 6 bits.
O primeiro campo das instruções é considerado o \emph{opcode} e tem de ter o
mesmo tamanho em todos os tipos.


\section{instructions}

Esta secção define as instruções disponíveis e como elas são codificadas.
Um exemplo da definição de uma instrução é mostrado abaixo:

\lstinputlisting{listings/instruction.txt}

Cada instrução é identificada pela sua mnemónica única (\verb+add+ neste exemplo),
Uma instrução é definida como um objecto JSON com várias propriedades. Estas são:

\begin{itemize}
	\item \textbf{type}: O tipo da instrução.
	\item \textbf{args}: Um \emph{array} com os tipos de cada argumento (pode ser
		omitido se a instrução não tiver argumentos).
		Os diferentes tipos de argumentos são:
		\begin{itemize}
			\item \textbf{reg}: Um registo.
			\item \textbf{int}: Um valor inteiro. Pode ser também uma etiqueta
				(permitido devido à pseudo-instrução \verb+la+).
			\item \textbf{target}: Uma etiqueta no código ou directamente o índice de
				uma instrução para um salto.
			\item \textbf{offset}: Uma etiqueta no código ou directamente um
				\emph{offset} de instruções para um \emph{branch}.
			\item \textbf{label}: Uma etiqueta no código ou segmento de dados ou
				directamente um endereço/índice.
			\item \textbf{data}: Uma etiqueta no segmento de dados ou directamente um
				endereço mais um registo de \emph{offset} para uma instrução de
				\emph{load} ou \emph{store} (um argumento como \verb+label($t0)+). O
				utilizador pode omitir o registo de \emph{offset}.
		\end{itemize}
	\item \textbf{fields}: Um objecto JSON que define os valores dos campos (os
		campos definidos no tipo da instrução). O valor de cada campo pode ser
		um inteiro constante ou vir de um argumento (especificado como \verb+"#1"+,
		\verb+"#2"+, etc.).
		Para valores que venham de um argumento \verb+data+ é necessário especificar
		se eles vêm de um endereço base ou de um registo de \emph{offset}.
		Isto é feito afixando \verb+.base+ ou \verb+.offset+ à referência para o
		argumento (\verb+#1+, \verb+#2+, etc.).
		
		Neste exemplo: \verb+op+ tem o valor constante \verb+0+, \verb+rs+ tem
		o valor do 2º argumento, \verb+rt+ tem o valor do 3º argumento, etc.
	\item \textbf{desc}: Opcional. Uma \emph{string} que deverá conter uma
		curta descrição simbólica do que a instrução faz para o utilizador ver.
\end{itemize}


\section{pseudo}

Esta secção define as pseudo-instruções disponíveis.
Um exemplo da definição de uma pseudo-instrução é mostrado abaixo:

\lstinputlisting{listings/pseudo.txt}

Cada pseudo-instrução é identificada pela sua mnemónica única (\verb+subi+
neste exemplo). Cada mnemónica apenas pode identificar uma instrução ou uma
pseudo-instrução, não as duas.
Uma pseudo-instrução é definida como um objecto JSON com várias propriedades.
Estas são:

\begin{itemize}
	\item \textbf{args}: Um \emph{array} com os tipos de cada argumento (pode ser
		omitido se a pseudo-instrução não tiver argumentos). Estes tipos são os
		mesmos que estão disponíveis para as instruções, explicados na secção
		anterior.
	\item \textbf{to}: Um \emph{array} que lista as instruções reais para as quais
		a pseudo-instrução é convertida quando assemblada. Os valores dos argumentos
		especificados pelo utilizador podem ser referenciados usando \verb+#1+ para
		o 1º argumento, \verb+#2+ para o 2º, e por assim adiante.
	\item \textbf{desc}: Opcional. Uma \emph{string} que deverá conter uma
		curta descrição simbólica do que a pseudo-instrução faz para o utilizador 
		ver.
\end{itemize}


\section{control}

Esta secção define como a unidade de controlo funciona. Mais especificamente,
define os valores das saídas (sinais de controlo) para cada valor possível na
entrada (o \emph{opcode}).
Um exemplo da definição dos valores dos sinais de control para um \emph{opcode}
é mostrado abaixo:

\lstinputlisting{listings/control.txt}

Os valores dos sinais de controlo para um certo \emph{opcode} são definidos como
um objecto JSON. Os valores estão em formato decimal e os tamanhos (em bits) dos
sinais de controlo são determinados automaticamente.
Sinais de controlo que têm o valor \verb+0+ podem ser omitidos.


\section{alu}

Esta secção define como a ALU e o controlador da ALU funcionam.
Um exemplo parcial desta secção é mostrado abaixo:

\lstinputlisting{listings/alu.txt}

As propriedades \verb+aluop_size+, \verb+func_size+ e \verb+control_size+
definem os tamanhos (em bits) das entradas \verb+ALUOp+ e \verb+func+ do
controlador da ALU e da entrada de controlo da ALU, respectivamente.

A subsecção \verb+control+ define como o controlador da ALU funciona (num
\emph{array} JSON).
Cada elemento no \emph{array} define (como um objecto JSON) os valores
das saídas para os valores das entradas especificados.
As propriedades \verb+aluop+ e \verb+func+ correspondem aos valores das
entradas para a correspondência. Se o valor da entrada \verb+func+ não for
relevante para a correspondência (\emph{don't care}, pode ser qualquer valor),
a propriedade pode ser omitida.
A propriedade \verb+out+ define os valores das saídas para a correspondência.
Os valores são especificados como um objecto JSON e os tamanhos (em bits) das
saídas são determinados automaticamente.
Todos os valores são em formato decimal.

A subsecção \verb+operations+ define (como um objecto JSON) a correspondência
entre os valores da entrada de controlo da ALU e a operação aritmética que a
mesma realiza.
As operações disponíveis são: \textbf{add}, \textbf{sub}, \textbf{and}, \textbf{or},
\textbf{slt}, \textbf{xor}, \textbf{sll}, \textbf{srl}, \textbf{sra}, \textbf{nor},
\textbf{mult}, \textbf{div}, \textbf{mfhi}, \textbf{mflo}.
Note que as últimas quatro operações exigem uma ALU ``estendida'' no CPU, ao
invés de uma ALU ``normal''.


\end{document}
